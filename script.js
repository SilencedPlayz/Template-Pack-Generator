if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js');
}
  const iconPrev = document.getElementById("pack-icon-preview")
  const iconFile = document.getElementById("pack-icon-file")
  let packName = document.getElementById("pack-name").value.trim() === "" ? "Template Pack" : document.getElementById("pack-name").value
  let packDesc = document.getElementById("pack-desc").value.trim() === "" ? "Template generated by Rex" : document.getElementById("pack-desc").value 
  const rpTogg = document.getElementById("rp-toggle")
  const bpTogg = document.getElementById("bp-toggle")
  const downloadBtn = document.getElementById("download")
  const downloadBlock = document.getElementById("download-block")
  const preview = document.getElementById("preview")
  const rpCheck = document.getElementById("rp")
  const bpCheck = document.getElementById("bp")
  
  //for intro animation
  setTimeout(()=>{
    document.getElementById("sign-in-form").style.opacity = "1"
    document.getElementById("sign-in-form").style.top = "50%"
    document.getElementById("fade-bg").style.zIndex = "-1"
  }, 500)
  
  setInterval(()=>{
    const detect = downloadBtn.getAttribute("download") === null ? "Null" : "Download"
    if(!rpCheck.checked && !bpCheck.checked){
      downloadBtn.style.filter = "grayscale(1) brightness(90%)"
      downloadBtn.style.cursor = "none"
    }else{
      downloadBtn.style.filter = "grayscale(0)"
      
    }
  }, 1)
  
  //for preview image
  iconFile.addEventListener("change", () => {
    const file = iconFile.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        iconPrev.src = e.target.result;
      };
      reader.readAsDataURL(file);
    } else {
      iconPrev.src = "./placeholder.png";
    }
  });
  
  downloadUpdate()
  rpCheck.addEventListener("change", downloadUpdate)
  bpCheck.addEventListener("change", downloadUpdate)
  function onInput(){
    packName = document.getElementById("pack-name").value.trim() === "" ? "Template Pack" : document.getElementById("pack-name").value;
    packDesc = document.getElementById("pack-desc").value.trim() === "" ? "Template generated by Rex" : document.getElementById("pack-desc").value;
    downloadBtn.download = packName.toLowerCase().replace(/ /g, "_")+".mcaddon";
    downloadUpdate()
  }
  
  async function downloadUpdate(){
    if(rpCheck.checked && bpCheck.checked){
      downloadADDON()
      downloadBlock.style.display = "none"
      downloadBtn.style.display = "block"
      downloadBtn.innerText = "Download"
    }else
    if(rpCheck.checked && !bpCheck.checked){
      downloadRP()
      downloadBlock.style.display = "none"
      downloadBtn.style.display = "block"
      downloadBtn.innerText = "Download rp"
    }else
    if(!rpCheck.checked && bpCheck.checked){
      downloadBP()
      downloadBlock.style.display = "none"
      downloadBtn.style.display = "block"
      downloadBtn.innerText = "download bp"
    }else
    if(!rpCheck.checked && !bpCheck.checked){
      downloadBtn.style.display = "none"
      downloadBlock.style.display = "block"
    }
  }
  async function downloadADDON(){
    const zip = new JSZip()
    const rpManifest = {
	    "format_version": 2,
	    "header": {
		    "name": "[RP] "+packName,
		    "description": packDesc,
		    "uuid": crypto.randomUUID(),
		    "version": [1, 0, 0],
		    "min_engine_version": [1, 20, 0]
	    },
	    "modules": [
		    {
			    "type": "resources",
			    "uuid": crypto.randomUUID(),
			    "version": [1, 0, 0]
		    }
	    ]
    }
    const bpManifest = {
      "format_version": 2,
      "header": {
        "name": "[BP] "+packName,
        "description": packDesc,
        "uuid": crypto.randomUUID(),
        "version": [1, 0, 0],
        "min_engine_version": [1, 21, 30]
      },
      "modules": [
        {
          "type": "data",
          "uuid": crypto.randomUUID(),
          "version": [4, 0, 0]
        },
        {
          "type": "script",
          "language": "javascript",
          "entry": "scripts/main.js",
          "uuid": crypto.randomUUID(),
          "version": [4, 0, 0]
        }
      ],
      "dependencies": [
        {
          "module_name": "@minecraft/server",
          "version": "1.14.0"
        },
        {
          "module_name": "@minecraft/server-ui",
          "version": "1.3.0"
        }
      ]
    }
    const mainJS = `import {world,system} from '@minecraft/server';
import {ActionFormData,ModalFormData,MessageFormData} from '@minecraft/server-ui';`
    
    const rp = zip.folder("RP")
    const bp = zip.folder("BP")
    
    rp.file("manifest.json", JSON.stringify(rpManifest, null, 1))
    bp.file("manifest.json", JSON.stringify(bpManifest, null, 1))
    bp.folder("scripts").file("main.js", mainJS)
    
    if (iconFile.files.length > 0) {
      const file = iconFile.files[0];
      rp.file("pack_icon.png", file);
      bp.file("pack_icon.png", file);
    } else {
      const response = await fetch("./placeholder.png");
      const blob = await response.blob();
      rp.file("pack_icon.png", blob);
      bp.file("pack_icon.png", blob);
    }
    
    const blob = await zip.generateAsync({type: "blob"})
    const url = URL.createObjectURL(blob);
    downloadBtn.href = url
    downloadBtn.download = packName.toLowerCase().replace(/ /g, "_")+".mcaddon"
  }
  async function downloadRP(){
    const zip = new JSZip()
    const rpManifest = {
	    "format_version": 2,
	    "header": {
		    "name": "[RP] "+packName,
		    "description": packDesc,
		    "uuid": crypto.randomUUID(),
		    "version": [1, 0, 0],
		    "min_engine_version": [1, 20, 0]
	    },
	    "modules": [
		    {
			    "type": "resources",
			    "uuid": crypto.randomUUID(),
			    "version": [1, 0, 0]
		    }
	    ]
    }
    const rp = zip.folder("RP")
    
    rp.file("manifest.json", JSON.stringify(rpManifest, null, 1))
    
    if (iconFile.files.length > 0) {
      const file = iconFile.files[0];
      rp.file("pack_icon.png", file);
    } else {
      const response = await fetch("./placeholder.png");
      const blob = await response.blob();
      rp.file("pack_icon.png", blob);
    }
    
    const blob = await zip.generateAsync({type: "blob"})
    const url = URL.createObjectURL(blob);
    downloadBtn.href = url
    downloadBtn.download = packName.toLowerCase().replace(/ /g, "_")+".mcpack"
  }
  async function downloadBP(){
    const zip = new JSZip()
    const bpManifest = {
      "format_version": 2,
      "header": {
        "name": "[BP] "+packName,
        "description": packDesc,
        "uuid": crypto.randomUUID(),
        "version": [1, 0, 0],
        "min_engine_version": [1, 21, 30]
      },
      "modules": [
        {
          "type": "data",
          "uuid": crypto.randomUUID(),
          "version": [4, 0, 0]
        },
        {
          "type": "script",
          "language": "javascript",
          "entry": "scripts/main.js",
          "uuid": crypto.randomUUID(),
          "version": [4, 0, 0]
        }
      ],
      "dependencies": [
        {
          "module_name": "@minecraft/server",
          "version": "1.14.0"
        },
        {
          "module_name": "@minecraft/server-ui",
          "version": "1.3.0"
        }
      ]
    }
    const mainJS = `import {world,system} from '@minecraft/server';
import {ActionFormData,ModalFormData,MessageFormData} from '@minecraft/server-ui';`
    const bp = zip.folder("BP")
    
    bp.file("manifest.json", JSON.stringify(bpManifest, null, 1))
    bp.folder("scripts").file("main.js", mainJS)
    
    if (iconFile.files.length > 0) {
      const file = iconFile.files[0];
      bp.file("pack_icon.png", file);
    } else {
      const response = await fetch("./placeholder.png");
      const blob = await response.blob();
      bp.file("pack_icon.png", blob);
    }
    
    const blob = await zip.generateAsync({type: "blob"})
    const url = URL.createObjectURL(blob);
    downloadBtn.href = url
    downloadBtn.download = packName.toLowerCase().replace(/ /g, "_")+".mcaddon"
  }
